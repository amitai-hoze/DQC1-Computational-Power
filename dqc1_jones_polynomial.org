* Libraries
** Haskell
:PROPERTIES:
:ID:       2b742f23-8fd3-45f9-988e-e4460e450408
:END:
#+name: knots-and-braids
#+begin_src haskell
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeFamilies #-}
import Diagrams.Prelude hiding (E)
import Data.List
import Data.Colour.SRGB
import Diagrams.TrailLike
import Diagrams.TwoD.Arrow
import Diagrams.TwoD.Arrowheads
import Diagrams.TwoD.Arc
import Diagrams.TwoD.Path.Metafont
import Diagrams.TwoD.Types
import Diagrams.TwoD.Path.Metafont.Types
import Diagrams.TwoD.Path.Metafont.Combinators
import Diagrams.TwoD.Vector
import Math.Projects.KnotTheory.TemperleyLieb
import Math.Projects.KnotTheory.Braid
import Math.Algebra.NonCommutative.NCPoly hiding (lc)
import Diagrams.TwoD.Text
import Diagrams.TwoD.Combinators

(-*) :: Int -> a -> [a]
(-*) n item = (replicate n item)

bottom i = p2 (i - 1, 0)
top i = p2 (i - 1, 10)
lowerMiddle i pos = p2 (i - 1, pos - 1)
upperMiddle i pos = p2 (i - 1, pos + 1)

-- A straight line
p .---. q = p .- tension 100 -. q

infixr 5 .---.

f % i = f . fromIntegral $ i

cross i j pos mfpath = bottom i.---.lowerMiddle i pos.--.upperMiddle j pos.---.top j.--.mfpath
crossAndEnd i j pos = bottom i.---.lowerMiddle i pos.--.upperMiddle j pos.---.endpt (top j)
closeTrace i n mfpath = p2 (2 * n - i,10).--.p2 (2 * n - i,0).--.mfpath where heightOffset = (n - (i - 1))
space n = square n # opacity 0
hequivalent n = arrowBetween' (with & arrowHead .~ dart & arrowTail .~ dart') (p2 (0,0)) (p2 (n,0))
vequivalent n = arrowBetween' (with & arrowHead .~ dart & arrowTail .~ dart') (p2 (0,0)) (p2 (0,n))

-- For seeing different trails
trailColors = cycle [aqua, orange, deeppink, blueviolet, crimson, darkgreen]

-- Coloring trails
trailsColored diagram colors = diagram # explodeTrail # zipWith lc colors # mconcat
#+end_src
* Research
** Unknotting problem

#+name: simple-unknot-algorithm
| step | below | above |
|------+-------+-------|
|    1 |     2 |       |
|    2 |       |     3 |
|    3 |     3 |       |
|    4 |       |     2 |
|    5 |       |     1 |
|    6 |     1 |       |

#+name: trefoil-algorithm
| step | below | above |
|------+-------+-------|
|    1 |     2 |       |
|    2 |       |     3 |
|    3 |     1 |       |
|    4 |       |     2 |
|    5 |     3 |       |
|    6 |       |     1 |

#+name: algorithm
| step | below | above |
|------+-------+-------|
|    1 |       |     2 |
|    2 |     3 |       |
|    3 |       |     4 |
|    4 |     5 |       |
|    5 |       |     6 |
|    6 |       |     7 |
|    7 |       |     8 |
|    8 |     9 |       |
|    9 |    10 |       |
|   10 |       |    11 |
|   11 |    12 |       |
|   12 |       |    13 |
|   13 |       |    14 |
|   14 |     8 |       |
|   15 |       |     3 |
|   16 |     2 |       |
|   17 |       |     1 |
|   18 |       |    10 |
|   19 |    13 |       |
|   20 |     6 |       |
|   21 |       |    15 |
|   22 |     4 |       |
|   23 |    11 |       |
|   24 |       |    12 |
|   25 |       |     5 |
|   26 |    15 |       |
|   27 |     7 |       |
|   28 |    14 |       |
|   29 |       |     9 |
|   30 |     1 |       |

** Culprit

#+name: culprit-stage-3
| step | below | above |
|------+-------+-------|
|    1 |     2 |       |
|    2 |     3 |       |
|    3 |       |     1 |
|    4 |       |     2 |
|    5 |       |     3 |
|    6 |     1 |       |

#+name: culprit-stage-4
| step | below | above |
|------+-------+-------|
|    1 |     2 |       |
|    2 |       |     4 |
|    3 |       |     5 |
|    4 |     3 |       |
|    5 |       |     1 |
|    6 |       |     2 |
|    7 |     4 |       |
|    8 |     5 |       |
|    9 |       |     3 |
|   10 |     1 |       |

#+name: culprit-stage-5
| step | below | above |
|------+-------+-------|
|    1 |       |     8 |
|    2 |       |     7 |
|    3 |     2 |       |
|    4 |       |     4 |
|    5 |     7 |       |
|    6 |     8 |       |
|    7 |       |     5 |
|    8 |     3 |       |
|    9 |       |     1 |
|   10 |       |     2 |
|   11 |     4 |       |
|   12 |     5 |       |
|   13 |       |     3 |
|   14 |     1 |       |

#+name: culprit-stage-6
| step | below | above |
|------+-------+-------|
|    1 |       |     8 |
|    2 |    11 |       |
|    3 |    10 |       |
|    4 |       |     7 |
|    5 |     2 |       |
|    6 |       |     4 |
|    7 |     7 |       |
|    8 |     9 |       |
|    9 |       |     9 |
|   10 |       |    10 |
|   11 |       |    11 |
|   12 |     8 |       |
|   13 |       |     5 |
|   14 |     3 |       |
|   15 |       |     1 |
|   16 |       |     2 |
|   17 |     4 |       |
|   18 |     5 |       |
|   19 |       |     3 |
|   20 |     1 |       |

#+name: culprit-stage-7
| step | below | above |
|------+-------+-------|
|    1 |       |     8 |
|    2 |    11 |       |
|    4 |       |     7 |
|    8 |     9 |       |
|    5 |     2 |       |
|    6 |       |     4 |
|    3 |    10 |       |
|    7 |     7 |       |
|    9 |       |     9 |
|   10 |       |    10 |
|   11 |       |    11 |
|   12 |     8 |       |
|   13 |       |     5 |
|   14 |     3 |       |
|   15 |       |     1 |
|   16 |       |     2 |
|   17 |     4 |       |
|   18 |     5 |       |
|   19 |       |     3 |
|   20 |     1 |       |

** Unknotting algorithm attempt                                     :ATTACH:
:PROPERTIES:
:Attachments: simple%20unknot_1.jpg simple%20unknot_2.jpg simple%20unknot_3.jpg simple%20unknot_4.jpg simple%20unknot_5.jpg recursive%20algorithm%20not%20working%20on%20trefoil.jpg
:ID:       a80e6450-c92f-49a0-b07f-f42473ddd5ad
:END:

org-display-inline-images

#+ATTR_HTML: :width 30px

[[file:data/a8/0e6450-c92f-49a0-b07f-f42473ddd5ad/simple%20unknot_2.jpg]]

#+name: simple-unknot-2
| > | 1 | < | 1 | > | 1 |

#+name: simple-unknot-3
| > | 1 | < | 2 | < | 3 | < | 1 | > | 2 | > | 3 | > | 1 |

#+name: simple-unknot-4
| > | 1 | < | 2 | < | 4 | > | 4 | < | 3 | < | 1 | > | 2 | > | 3 | > | 1 |

#+name: simple-unknot-5
| > | 1 | < | 4 | < | 3 | < | 2 | > | 4 | < | 1 | > | 2 | > | 3 | > | 1 |

#+begin_src haskell :tangle haskell/unknot.hs :results output
import Data.List
import Data.List.Split
simple_unknot_3 = ">1<2<3<1>2>3>1"
simple_unknot_4 = ">1<2<4>4<3<1>2>3>1"
simple_unknot_5 = ">1<4<3<2>4<1>2>3>1"

separate_ops :: [Char] -> [[Char]]
separate_ops exp = tail (split (oneOf "<>") exp)

sep = separate_ops simple_unknot_4

simplify :: [[Char]] -> [[Char]]
simplify [] = []
simplify (">":a:"<":b:"<":c:"<":d:">":e:">":f:tail)
         | a==d&&b==e&&c==f = simplify(tail)
         | otherwise = [">",a,"<",b,"<",c,"<",d,">",e,">",f] ++ simplify(tail)
simplify tail = tail

main = do
     --putStrLn (concat (reduce [">1<2<3"]))
     putStrLn (show (simplify sep))
     --putStrLn (concat (simplify simple_unknot_2))
#+end_src

#+RESULTS:
: [">","1","<","2","<","4",">","4","<","3","<","1",">","2",">","3",">","1"]

* Diagrams
** Unknot equivalent
#+name: unknot-equivalent
#+begin_src haskell :noweb yes :tangle haskell/unknot_equivalent.hs :exports none
<<knots-and-braids>>
<<beside-operators>>

underLinePoint x = p2 (x, 1-x)

unknotEquivalent = metafont $ p2 (0,0).---.p2 (1,1).--.underLinePoint 0.---.underLinePoint 0.45.---.underLinePoint 0.55.---.underLinePoint 1.--.cyclePath

unknotEquivalentColors = (3 -* black) ++ [white] ++ (3 -* black)

unknotEquivalentColored = trailsColored unknotEquivalent unknotEquivalentColors

--main = mainWith (dia)
--dia :: Diagram B R2
dia = (unknotEquivalentColored # center) --> space 0.2 --> hequivalent 1--> space 0.2 --> circle 1.5
#+end_src
** Unknot equivalent braid representation
:PROPERTIES:
:ID:       f2e012db-950a-4034-8887-336184ab3cc2
:END:
#+name: unknot-equivalent-braid-representation
#+begin_src haskell :noweb yes :tangle haskell/unknot_equivalent_braid_representation.hs :exports none
<<knots-and-braids>>
<<beside-operators>>

n = 2
traceClosure = metafont $ cross 1 2 5 . closeTrace 2 n . cross 2 1 5 . closeTrace 1 n $ cyclePath

--traceClosureColored = traceClosure # explodeTrail # zipWith lc colors # mconcat
traceClosureDashing = (2 -* ((3 -* []) ++ (3 -* [0.01, 0.01]))) # concat

dia = traceClosure # explodeTrail # zipWith3 dashingN traceClosureDashing (12 -* 0) # mconcat
#+end_src
** Temperley Lieb Diagram
:PROPERTIES:
:ID:       155444b9-fe48-4d2c-b0e5-333c1a7173d6
:END:
#+name: tl-diagram
#+begin_src haskell :noweb yes :tangle haskell/tl_diagram.hs :exports none
<<knots-and-braids>>
<<beside-operators>>

upArc i = metafont $ p2 (i,2).--.p2 (i+1/2,1.5).--.endpt (p2 (i+1,2))
downArc i = metafont $ p2 (i,0).--.p2 (i+1/2,1/2).--.endpt (p2 (i+1,0))
line i = metafont $ p2 (i,0).--.endpt (p2 (i,2))

traceStyle a = a # dashingN [0.01, 0.02] 0 # lc red

tlTraceClosure i = (metafont $ p2 (i,0).- leaving unitX <> tension 7 <> arriving unit_X -.endpt (p2 (i,2))) # traceStyle

fromTlGen :: Bool -> Int -> TemperleyLiebGens -> Diagram B
fromTlGen tc n e@(E j) = upArc % j <> downArc % j <> (mconcat [line % i | i <- [1..(j-1)] ++ [(j+2)..n]]) <> (if tc then (mconcat [tlTraceClosure % i | i <- [1..n]]) else mempty)

fromTlGens :: Bool -> Int -> [TemperleyLiebGens] -> Diagram B
fromTlGens tc n [] = mconcat [line % i <> (if tc then tlTraceClosure % i else mempty) | i <- [1..n]]
fromTlGens tc n g  = vcat [fromTlGen tc n e | e <- g]

text' s t = text t # fontSize (local s) # scale 0.5 <> strutX (s * 1.4)

charMapping c = case c of
            'a' -> 'A'
            '0' -> '\x2070'
            '1' -> '\xb9'
            '2' -> '\xb2'
            '3' -> '\xb3'
            '4' -> '\x2074'
            '5' -> '\x2075'
            '6' -> '\x2076'
            '7' -> '\x2077'
            '8' -> '\x2078'
            '9' -> '\x2079'
            '+' -> '\x207A'
            '-' -> '\x207B'
            '=' -> '\x207C'
            '(' -> '\x207D'
            ')' -> '\x207E'
            'i' -> '\x2071'
            'n' -> '\x207F'
            otherwise -> c

toArticleRepresentation exp = filter (\c -> c /= '^') (map charMapping exp)

tlCoefficient i c = text' 1.15 ((if i==1 then "" else "+") ++ (toArticleRepresentation (show c)))

fromTL :: Bool -> Bool -> Int -> NPoly LPQ TemperleyLiebGens -> Diagram B
fromTL ce tc n f@(NP ts) = hcat [(if ce then (tlCoefficient i c) else mempty) ||| (fromTlGens tc n g # center) | (i,(m@(M g),c)) <- (zip [1..] ts)]
#+end_src
** Trefoil
:PROPERTIES:
:ID:       6eb07fb0-818e-421a-904b-379925cc8870
:END:
#+name: trefoil
#+begin_src haskell :noweb yes :tangle haskell/trefoil.hs :exports none
<<knots-and-braids>>
<<beside-operators>>

underLinePoint x = p2 (x, 1-x)

trianglePoint :: R2 -> P2
--trianglePoint i = (trailVertices (triangle 1)) !! i

trianglePoint i = case i of 1 -> p2 (0,0)
                            2 -> p2 ( 1, sqrt 3)
                            3 -> p2 (-1, sqrt 3)


foldln f z (x:xs) = foldln f (f z x) xs

--ptIndices :: [R2]
--ptIndices = [x::R2 | x <- [1..3]]

trefoil = metafont $ foldl traverse cyclePath (zip [1..] [1,2,3,1,2,3])
--trefoil = metafont $ foldl rightJoin (endpt (trianglePoint 1)) (map trianglePoint [1,2,3,1,2,3])

traverse :: MFPathData P -> (Int, R2) -> MFPathData P
traverse mf (i,tp)
         | (mod i 2) == 0 = (trianglePoint tp).--.mf
         | otherwise    = (trianglePoint tp).- tension 1.4 -.mf

unknotEquivalentColors = (3 -* black) ++ [white] ++ (3 -* black)

--unknotEquivalentColored = trailsColored unknotEquivalent unknotEquivalentColors

main = mainWith (dia)
dia :: Diagram B R2
dia = trefoil
#+end_src
** Fibonacci representation
:PROPERTIES:
:ID:       f2e012db-950a-4034-8887-336184ab3cc2
:END:
#+name: fibonacci-representation
#+begin_src haskell :noweb yes :tangle haskell/fibonacci_representation.hs :exports none
<<knots-and-braids>>
<<beside-operators>>

-- The number of strands
--n = 2

-- The intersection rectangle height/2
rX = 1/20

-- The intersection rectangle width/2
rY = rX*l/3

-- the intersection direction depending on the x-axis direction d
rV2 d = r2 (rX*d,rY)

-- The height of a strand
l = 2

-- The x axis distance between two pegs/2
mX = 1/2

-- The y axis distance between two pegs/2
mY = l/2

straightStrand i = metafont $ p2 (i,0).--.endpt (p2 (i,2))

startX i = abs(i)-((signum i)-1)/2

upperStrand i = metafont $
            p2 (s,0)               .-    leaving unitY <> arriving (rV2 d) -.
            p2 (s+d*(mX-rX),mY-rY) .--.
            p2 (s+d*(mX+rX),mY+rY) .-    leaving (rV2 d) <> arriving unitY  -.
            endpt (p2 (s+d,l))
                  where s = startX i
                        d = signum i

lowerStrandHalf1 i = metafont $
                 p2 (e,0)        .-    leaving unitY <> arriving (rV2 (-d))  -.
                 endpt (p2 (e-d*(mX-rX),mY-rY))
                       where e = (startX i) + (signum i)
                             d = signum i

lowerStrandHalf2 i = metafont $
                 p2 (e-d*(mX+rX),mY+rY) .- leaving (rV2 (-d)) <> arriving unitY -.
                 endpt (p2 (e-d,l))
                       where e = (startX i) + (signum i)
                             d = signum i

lowerStrand i = (lowerStrandHalf1 i) <> (lowerStrandHalf2 i)

fromBraidGen (S i) n = upperStrand % i <> lowerStrand % i <> (mconcat [straightStrand % j | j <- [1..(i-1)] ++ [(i+2)..n]])

fromBraidGens :: NPoly LPQ BraidGens -> Int -> Diagram B
fromBraidGens (NP [(M xs,c)]) n = vcat [fromBraidGen bg n | bg <- xs]

#+end_src
*** l/3 explanation
In order to get to the coefficient of the intersection rectangle [[l/3]], I took a polynom:

\begin{align*}
P(x)=x^3+bx^2+cx+d
\end{align*}

and said that
\begin{align*}
&P(0)=1, P'(0)=0 \\
&P(l)=0, P'(l)=0
\end{align*}

so:
\begin{align*}
P(0)=1 \Rightarrow a\cdot0^3+b\cdot0^2+c\cdot0+d=1 &\Rightarrow d=1 \\
P'(0)=0 \Rightarrow 3a\cdot0^2+2b\cdot0+c=0 &\Rightarrow c=0 \\
P'(l)=0 \Rightarrow 3a \cdot l^2 + 2b \cdot l = 0 &\Rightarrow b=-\frac{3}{2}a \cdot l \\
P(l)=0 \Rightarrow a \cdot l^3 + b \cdot l^2 + 1 = 0 \Rightarrow a \cdot l^3 - \frac{3}{2}a \cdot l^3 +1=0 &\Rightarrow a=\frac{2}{l^3} \\
\end{align*}

And:
\begin{align*}
P'\left(\frac{l}{2}\right)=3a \cdot \left(\frac{l}{2}\right)^2 + 2b \cdot \frac{l}{2} = \dots = \frac{l}{3}
\end{align*}

* DQC1 complexity class and the trace estimation problem
:PROPERTIES:
:EXPORT_LaTeX_CLASS: beamer
:EXPORT_LaTeX_CLASS_OPTIONS: [leqno,fleqn]
:EXPORT_BEAMER_THEME: PaloAlto
:EXPORT_OPTIONS: H:2
:EXPORT_LaTeX_HEADER: \input{dqc1_headers}
:EXPORT_FILE_NAME: dqc1_trace_estimation_beamer
:END:

#+author:Ohad Barta, Amitai Hoze

** The DQC1 complexity class
*** The DQC1 complexity class
DQC1 class is the class of decidable languages with algorithm $A$ such that:

-  $A$ starts with one clean qubit in state $\ket{0}$, and $n$ qubits in
   the maximally mixed state
-  $A$ may perform any unitary operation
-  $A$ can only perform a measurement of the clean qubit at the end of
   the algorithm (no middle-algorithm measurements allowed)
-  $A$ has access to a classical computer for the circuit-building purposes (or for just decide the problem, so \(P \subset DQC1\))
-  $A$ runs in polynomial time
-  $\forall x$, $A$ decides if $x \in L$ correctly with probability of
   at least $\frac{2}{3}$
*** The trace estimation problem is in DQC1
**** Trace estimation problem
Given a quantom circuit, what is the trace of its unitary operation?
*** Languages and Completness
**** Language
A Language is a finite, or an infinite set of words. $x \in L$ if the word $x$ is in this set.
**** Examples
-  $L$ is the language of all the strings that start with 0. $015 \in L$,
   but $501 \notin L$.
-  $L$ is the language of all prime numbers. $1 \in L$, $101 \in L$,
   but $15 \notin L$.
**** $L \in P$
$L$ is decidable in polynomial time, if there is some algorithm $A$ which runs in polynomial time, such that for every word $x$
it decides correctly if $x \in L$. We will say that such an algotrithm "Solves L"
*** Languages and Completness
**** Reduction
Let $L_{1}, L_{2}$ be two languages. $L_1$ is reducible to $L_2$ if there is a
function $f:L_1 \rightarrow L_2$, such that:
$f(x) \in L_{2}$ iff $x \in L_{1}$.
**** Algorithm
An algorithm for the decision problem $x \in L_{1}$ will simply check if $f(x) \in L_{2}$.
**** Example
Let $L_{1}$ be the set of all the words that start with "0", and $L_{2}$ the set of all the words that start with "1". A reduction from $L_{1}$ to $L_{2}$ will just flip the MSB of the given word.
*** Languages and Completness
**** Why languages?
We are used to discussing the complexity of a *function problem* rather than a *decision problem*, so why languages?
**** $P$ vs $FP$
- $P$ - the class of decision problems that can be computed in polynomial time
- $FP$ - the class of function problems that can be computed in polynomial time
- $P \subset FP$
- Sometimes there is a decision problem for a function problem s.t. the decision problem is in class $P$ iff the function problem is in class $P$, but not always
*** Languages and Completness
**** So why?
It's mainly for historical reasons, as Scott Aaronson says in a comment:
#+begin_quote
No, decision problems aren’t that much easier to handle, and indeed these days people talk about other types of problems (e.g., sampling and search problems) plenty often. On the other hand, when you’re comparing different complexity classes, it helps to have a uniform standard.
#+end_quote
*** The trace estimation problem is in DQC1
**** Completeness
A language L is said to be "complete" in the class DQC1, if:
- $L \in DQC1$
- $\forall L_{0} \in DQC1$ there is a reduction from $L_{0}$ to $L$, such that the reduction algorithm is in DQC1
*** The Hadamard test
:PROPERTIES:
:ID:       26221cd6-2605-47d5-ba43-b0c03df22c36
:END:
:source_table:
#+name: hadamard-test
| \lstick{\ket{0}} | \gate {H} | \ctrl{1}  | \gate {H} | \meter | \qw |
| \lstick{\psi}   | {/} \qw    | \gate {U} | {/} \qw    | \qw    | \qw |
:end:
#+begin_src latex :noweb yes
\inlineQcircuit{
  <<org-table-to-latex-matrix(hadamard-test)>>
}
#+end_src
*** The Hadamard test
We will show that this circuit indeed calculates the trace of U
**** After the first hadamard gate
\begin{align*}
   \Ket{+}\psi = \frac{1}{\sqrt{2}}\Ket{0}\Ket{\psi} + \frac{1}{\sqrt{2}}\Ket{1}\Ket{\psi}
\end{align*}
**** After the C-U operation
\begin{align*}
   \frac{1}{\sqrt{2}}\Ket{0}\Ket{\psi} + \frac{1}{\sqrt{2}}\Ket{1}U\Ket{\psi}
\end{align*}
**** After the final hadamard operation
#+begin_src latex
\begin{align*}
   \frac{1}{2}\Ket{0}\Ket{\psi} + \frac{1}{2}\Ket{1}\Ket{\psi}\ +\frac{1}{2}\Ket{0}U\Ket{\psi}\ -  \frac{1}{2}\Ket{1}U\Ket{\psi} = \\
   \frac{\Ket{\psi} + U\Ket{\psi}}{2}\Ket{0} + \frac{\Ket{\psi} - U\Ket{\psi}}{2}\Ket{1}
\end{align*}
#+end_src
*** The Hadamard test
Therefore, the propability to measure 0 at the end is:

\begin{align*}
\rho_{0} &= (\frac{\bra{\psi} + \bra{\psi}U^\dagger}{2})(\frac{\ket{\psi} + U\ket{\psi}}{2}) = \\
    &= \frac{1}{4}(\bra{\psi}\ket{\psi} + \bra{\psi}U^\dagger\ket{\psi} + \bra{\psi}U\ket{\psi} + \bra{\psi}U^\dagger U\ket{\psi}) = \\
    &= \frac{1}{2} + \frac{1}{4}(\bra{\psi}U^\dagger\ket{\psi} + \bra{\psi}U\ket{\psi}) = \\
    &=  \frac{1}{2} + \frac{1}{2}Re(\bra{\psi}U\ket{\psi})
\end{align*}
*** The Hadamard test
As $\psi$ is the completely mixed state, the probability is: \\
\begin{align*}
  \frac{1}{2^{n}}\sum_{x \in \{0,1\}^n}{\frac{1+Re(\bra{x}U\ket{x})}{2}} = \frac{1}{2} + \frac{Re(TrU)}{2^{n+1}}
\end{align*}
Therefore, the problem of trace estimation can be solved with one clean qubit.
** Completeness of trace estimation in DQC1
*** Trace estimation is in DQC1
The start state of any DQC1 problem is one clean qubit (state \(\ket{0}\)), and $n$-qubits in the maximally mixed state. That is, the start state is $\rho = \ket{0}\bra{0} \otimes \frac{I}{2^n}$. We can use the Hadamard test in order to estimate a trace of a unitary operation $U$.
*** Trace estimation is in DQC1
**** Proof
Suppose we have some language $L \in DQC1$, and some $x$, and we want to decide if $x \in L$. We apply a unitary matrix $U$ on the DQC1 start state $\rho=\ket{0}\bra{0}\frac{I}{2^n}$ and get the state $\rho_{final} = U \rho U^\dagger = U\ket{0}\bra{0}\frac{I}{2^n}U^\dagger$.
The probability to measure 0 equals to the trace of the final matrix, when we enforce the first bit to be zero, or:
\begin{align*}
 p_{0} &= Tr[(\ket{0}\bra{0}\otimes I)\rho_{final}] \\
     &= 2^{-n}Tr[(\ket{0}\bra{0} \otimes I)U(\ket{0} \bra{0} \otimes I)U^\dagger]
\end{align*}
Unfortunately - this matrix isn't unitary!!
*** Trace estimation is in DQC1
To resolve this issue, we examine the following quantom circuit C:
:source_table:
#+name: trace-estimation
|   | \qw    | \multigate{1}{U^\dag} | \ctrl{2} | \multigate{1}{U} | \ctrl{3} | \qw    |
|   | {/} \qw | \ghost{U^\dag}       | \qw      | \ghost{U}        | \qw      | {/} \qw |
|   | \qw    | \qw               | \targ    | \qw              | \qw      | \qw    |
|   | \qw    | \qw               | \qw      | \qw              | \targ    | \qw    |
:end:
#+begin_src latex :noweb yes
\inlineQcircuit{
  <<org-table-to-latex-matrix(trace-estimation)>>
}
#+end_src
**** Proposition 1
 $\frac{1}{4}Tr[C]=Tr[(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I)U^\dagger]$
*** Trace estimation is in DQC1
**** 
$Tr[C] = \sum_{x \in \{0,1\}^n} \bra{x}C\ket{x}$, and in a similar way,
\begin{align*}
&Tr[(\ket{0}\bra{0} \otimes I)U(\ket{0}\bra{0} \otimes I)U^\dagger] = \\
&= \sum_{x \in \{0,1\}^n} \bra{x}(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I{U^\dagger})\ket{x}
\end{align*}
**** 
Suppose that after applying $U$ on some state $\psi$, we got a non-zero component in the first qubit.
**** 
After the CNOT gate, this component will flip one of the last qubits, creating a new state that is orthogonal to $\psi$.
**** 
By the equation above, we see that in this case, this component would contribute nothing to the trace of C.
*** Trace estimation is in DQC1
**** 
On the other hand, the zero-component we get after applying $U$ on $\psi$, doesn't change the last qubit, so the contribution to the trace of C will be $\bra{\psi}(\bra{0}\ket{0} \otimes U)\ket{\psi}$
**** 
After considering the two CNOT gates, the contribution of $\psi$ to the trace of C will be $\bra{\psi}(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I{U^\dagger})\ket{\psi}$
**** 
Therefore, the two circuit traces has the exact same components and are equal, up to factor of 4, which comes from the "free choice" in the values of the two last qubits in C.
*** Trace estimation is DQC1 complete
- We didn't compute the trace accurately, rather got an approximation via the expectation of the algorithm.
- According to the Chernoff inequality (which says: \(Pr[X > np +x] \leq e^{\frac{-x^{2}}{2np(1-p)}}\)), the probability of being wrong with more then $\frac{1}{n}$, is at most $O(e^{-n})$, so we can assume (with probability of almost 1), that we got a polynomial approximation to the trace.
*** Trace estimation is DQC1 complete
-  On the other hand, an approximation of $\frac{1}{poly(n)}$ to the
   expression $\frac{Tr(U)}{2^{n+1}}$ is enough to decide every problem
   in DQC1 using the analysis above
-  Therefore, we showed that getting a $\frac{2^{n}}{poly(n)}$ additive-
   approximation to the trace is a DQC1-complete problem
** Adding few more clean bits doesn't give extra power
*** Adding few more clean bits doesn't give extra power
**** DQCK
A's start state includes K clean qubits. In case that the input $x \in L$, 0 will be measured in the first clean qubit at the end of A with probability of at least $\frac{2}{3}$
*** Adding few more clean bits doesn't give extra power
We will now prove that for $k \leq \log{n}$, estimating the trace of a unitary matrix with the same precision is still a complete problem \cite{shor2008estimating}.

This proves that adding logarithmic number of clean bits doesn't change the computaional power.
Obviously we can calculate the trace of unitary matrix with $\log{n}$ bits, since we can do it just with one. 
*** Adding few more clean bits doesn't give extra power
As for the less trivial direction, assume we have some quantum algorithm in DQCK.
Similarly to the one-qubit option, final state is:
$\rho_{final} = U \rho U^\dagger = U\ket{0}\bra{0}^{\otimes k}\frac{I}{2^n}U^\dagger$
The probability of measuring 0 at the end is:
$p_{0} = Tr[(\ket{0}\bra{0} \otimes I)\rho_{final}] = 2^{-n}Tr[(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}^{\otimes k }\otimes I)U^\dagger$

This matrix is not unitary as well!
To resolve this, we build circuit similar to the one in the 1-clean qubit process,
but now we add additional $k-1$ ancilla qubits with a CNOT gate between the $2 \dots k$ clean qubits, and the corresponding ancilla qubits (thus enforcing them to be zero in order to contribute to the circuit's trace).
*** Adding few more clean bits doesn't give extra power
:source_table:
#+name: k-trace-estimation
| \qw | {/} \qw | \multigate{1}{U^\dag} | \ctrl{2} | \multigate{1}{U} | \ctrl{3} | {/} \qw | \qw |
| \qw | {/} \qw | \ghost{U^\dag}        | \qw      | \ghost{U}        | \qw      | {/} \qw | \qw |
| \qw | {/} \qw | \qw                | \targ    | \qw              | \qw      | {/} \qw | \qw |
| \qw | \qw    | \qw                | \qw      | \qw              | \targ    | \qw    | \qw |
:end:
#+begin_src latex :noweb yes
\inlineQcircuit{
  <<org-table-to-latex-matrix(k-trace-estimation)>>
}
#+end_src
Now, we can see (similarly to the proposition 1), that the trace of the new circuit $U^*$ follows the rule: $Tr[U^{*}] = 2^{k}Tr[U]$. Thus, in polynomial number of executions we can compute its trace up to a percision of $\frac{2^{n+k}}{poly(n,k)}$, but this equals to $\frac{2^{n}}{poly(n)}$ when $k  \leq \log{n}$, which means that in this case the precision is good enough to decide the original problem.

** References
*** References
\bibliographystyle{plain}
\bibliography{dqc1}
* Computing the Jones Polynomial in DQC1
** Computing the Jones Polynomial in DQC1
:PROPERTIES:
:EXPORT_LaTeX_CLASS: beamer
:EXPORT_LaTeX_CLASS_OPTIONS: [leqno,fleqn]
:EXPORT_BEAMER_THEME: PaloAlto
:EXPORT_OPTIONS: H:2 d:nil
:EXPORT_LaTeX_HEADER: \input{dqc1_headers}
:EXPORT_FILE_NAME: computing_the_jones_polynomial_in_dqc1_beamer
:END:

#+author:Ohad Barta, Amitai Hoze

#+beamer: \beamerdefaultoverlayspecification{<+->}
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt) 
*** Reminder
**** The main results
***** 
The relation between the trace of the Temperley-Lieb object and the Jones Polynomial:
\\
#+begin_src latex
\begin{align*}
V_{b^{tr}}(A^{-4})=(-A)^{3w(b^{tr})}D^{n-1}Tr(\rho_A(b^{tr}))
\end{align*}
#+end_src
***** 
The relation between the trace of the Temperley-Lieb and the trace of the Fibonacci representation of braid $b$, when $A=e^{-i3\pi/5}$
\\
#+begin_src latex
\begin{align*}
Tr(\rho_F^{(n)}(b))=Tr(\rho_A(b))
\end{align*}
#+end_src

*** A simple example
**** A knot
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** A simple knot $k$ equivalent to the unknot

#+begin_src latex :noweb yes
\begin{diagram}[width=200,height=100]
<<unknot-equivalent>>
\end{diagram}
#+end_src
**** The corresponding braid
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** A braid $b$ such that $b^{tr}$ is $k$

#+begin_src latex :noweb yes
\begin{diagram}[width=300,height=150]
<<unknot-equivalent-braid-representation>>
\end{diagram}
#+end_src
**** The braid group generators
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $s_1$
#+begin_src latex :noweb yes
\begin{diagram}[width=300,height=150]
<<fibonacci-representation>>
dia = fromBraidGens (s1) 2
\end{diagram}
#+end_src
**** The braid group generators
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $s_1 s_2$
#+begin_src latex :noweb yes
\begin{diagram}[width=300,height=150]
<<fibonacci-representation>>
dia = fromBraidGens (s1*s2) 3
\end{diagram}
#+end_src
**** Temperley-Lieb objects
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $E_1$
#+begin_src latex :noweb yes
\begin{diagram}[width=300,height=150]
<<tl-diagram>>
dia = fromTL False False 2 (e1)
\end{diagram}
#+end_src
**** The Markov trace for TL objects
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $E_1$ trace closure                                        :B_block:BMCOL:
:PROPERTIES:
:BEAMER_COL: 0.3
:BEAMER_ENV: block
:END:

#+begin_src latex :noweb yes
\begin{diagram}[width=60,height=100]
<<tl-diagram>>
dia = fromTL False True 2 (e1)
\end{diagram}
#+end_src
***** Calculating the trace                              :B_block:BMCOL:
:PROPERTIES:
:BEAMER_COL: 0.6
:BEAMER_ACT: <2->
:BEAMER_ENV: block
:END:

#+begin_src latex
Definition:\\
\begin{align*}
  &\forall t \in TL_n(d) \\
  &Tr(t) = d^{a-n}
\end{align*}
Therefore\\
\begin{align*}
Tr(E_1) = d^{a-n} = d^{1-2} = d^{-1}
\end{align*}
#+end_src
**** Temperley-Lieb objects
***** The Homomorphism between the braids group and the Temperley-Lieb objects
#+begin_src latex
\begin{align*}
\rho_A(\sigma_i)=AE_i+A^{-1}I
\end{align*}
#+end_src
**** The $\rho_A$ Homomorphism
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $\rho_A(\sigma_1)=AE_1+A^{-1}I$
#+begin_src latex :noweb yes
\begin{diagram}[width=200,height=100]
<<tl-diagram>>
dia = fromTL True False 2 (fromBraid s1)
\end{diagram}
#+end_src

**** Calculating the trace
:PROPERTIES:
:BEAMER_opt: fragile
:END:
***** $Tr(\rho_A(\sigma_1))=A \cdot Tr(E_1)+A^{-1} \cdot Tr(I)$
#+begin_src latex :noweb yes
\begin{diagram}[width=200,height=100]
<<tl-diagram>>
dia = fromTL True True 2 (fromBraid s1)
\end{diagram}
#+end_src

**** COMMENT What's the problem
***** What's the problem?
As shown in the previous presentation, we have:
- A method to approximate the Jones polynomial using the trace of a unitary matrix
- An algorithm for trace estimation in DQC1

#+latex: \onslide<4->{
What more could we possibly need?
#+latex: }
***** An exponentially small submatrix
Alas, as shown in the previous presentation, we can't compute an exponentially small submatrix efficiently..
**** COMMENT Calculation
#+begin_src octave
angle = -2 * pi / 5
tao = 2 / (1 + sqrt(5))
x = 1 + sqrt(2) + sqrt(2) * tao

ans = e^(angle*i)*(sqrt(2)/tao + x) + e^(2 * angle * i)*x
#+end_src

#+RESULTS:
: -0.9370160244488204-7.236340591481184i

#+begin_src octave
A = e^((-3 * pi / 5) * i)
tao = 2 / (1 + sqrt(5))
a = -A^4
b = A^8
c = A^8*tao^2 - A^4*tao
d = A^8*tao^(3/2) + A^4*tao^(3/2)
E = A^8*tao - A^4*tao^2 
phi = (1 + sqrt(5))/sqrt(2)
ans = phi * a + b + phi * c + a + phi * E
#+end_src

#+RESULTS:
: -4.383477137944906+3.370776039040406i

#+begin_src octave
t = e^((2 * pi / 5) * i)
#A = e^((-3 * pi / 5) * i)
A = t^(-1/4)
d = -A^2 - A^(-2)
ans = A*d^(-1) + A^(-1)
#+end_src

#+RESULTS:
: 0.3632712640026806+0.5i

*** The Zeckendorf representation
**** Zeckendorf, you're a genius
***** Definition
- Let $P_n$ be the set of $n$ strings of the $p$ and $*$ symbols described earlier
- Let $f_n$ be the $n^{th}$ Fibonacci number
- Let the number $z(s)$ defined below be the number corresponding to the string $s$ in the Zeckendorf representation
#+begin_src latex
\begin{align*}
z(s) = \sum_{i=1}^n{s_if_{i+1}}
\end{align*}
#+end_src
***** Bit representation of the Zeckendorf representation
For every string $s$ in $P_n$ there is a bit string of length $b=\lceil\log_2(f_{n+2})\rceil$ representing $z(s)$.
# *Show intuition*
**** The Zeckendorf representation
***** The resulting submatrix dimension
As we get rid of unnecessary options, the dimension of the encoded sumatrix is at least half of the dimension of the total matrix
# *show proof/intuition*
*** The algorithm
**** The algorithm
***** The quantum computer
The computer will consist of $O(1)$ pure qubits and $b$ maximally mixed qubits
***** The quantum circuits
- For each crossing in the braid, we construct a quantum circuit that decodes the corresponding qubits in the Zeckendorf representation to the Fibonacci representation triplet containing that crossing.
- We then apply the *local* linear transformation that creates that crossing
- We then encode the triplet back to the Zeckendorf representation
**** The algorithm
***** Obtaining the Jones polynomial approximation
- We multiply the quantum circuits we built, and perform a trace estimation in DQC1,
- We can use the resulting trace estimation to approximate the Jones polynomial

Yes! we're done!
***** Wait!
Decoding with a DQC1 computer? How were you thinking to do that? You have only one pure qubit, all the others are mixed!
*** Getting the Fibonacci triplets for each crossing from the Zeckendorf representation
**** We can get the leftmost symbol though..
***** Getting the leftmost symbol
- We know that $z(s) \ge f_{n-1} \Leftrightarrow \text{The leftmost symbol is *}$
- Take a clean ancilla qubit $q$ in the state $\ket{0}$.
- If $z(s) \ge f_{n-1}$ flip $q$.
- Make a controlled $z(s)=z(s)-f_{n-1}$ where $q$ is the control.
- The ancilla qubit now contains the leftmost symbol (\(p \to 0, * \to 1\))
- The Zeckendorf representation now corresponds only to $n-1$ Fibonacci representation qubits
**** Performing the arithmetic operations
***** Potential problem with using classical circuits
- Any classical circuit can be made reversible with constant overhead \cite{nielsen2010quantum}
- The resulting reversible circuit may require additional clean ancilla qubits
- We only have one..
**** Performing the arithmetic operations
***** Solution
- The basic operations of arithmetic and comparison for integers can be implemented using logarithmic depth circuits \cite{wegener1987complexity}
- As shown in \cite{ambainis2000computing}, any logarithmic depth classical circuit can be converted into a reversible circuit using only 3 clean ancillas
- As shown in the presentation on trace estimation using DQC1, DQCK where $k \le \log(n)$ is equivalent to DQC1
***** We don't want the leftmost, we want all of them! Focus!
Well, we actually *can* reduce the problem of extracting an arbitrary symbol to the problem of extracting the leftmost
**** See? there's a reduction..
***** Example
| \rightarrow |   |   |   |    |   |   |   |   | \leftarrow |
| 1 | 2 | 3 | 5 | 13 | 8 | 5 | 3 | 2 | 1 |
| / |   |   |   | >  | < |   |   |   |   |
| * | p | p | * | p  | p | * | p | p | p |
***** Splitting the string
Instead of transforming the entire string to the Zeckendorf representation, we split the string into two strings, and for each of them find its Zeckendorf number. Now we can get the (mirrored) leftmost symbol of the right string as well.
**** Algorithm for getting the \(i\)th symbol
***** Moving the splitting point
- Check whether the leftmost symbol of the right string is * as described above.
- If so, subtract $f_l$ from the right string and add $f_m$ to the left string, where $l$ and $m$ are the lengths of the first and second strings correspondingly
- Note that left string is read from right to left, and the right string is read from left to right
***** Getting the $i^{th}$ symbol
Just move the splitting point to be between the $i^{th}$ and the $(i-1)^{th}$, and then read the leftmost symbol of the right string.
**** Getting an arbitrary symbol
***** Cleaning up
At the end we move the splitting point all the way to the left, leaving us with the original Zeckendorf representation.
*** Getting the weighted trace
**** Getting the weighted trace
***** Weighted?
In order for the trace of the Fibonacci representation unitary matrix to be equal to the Jones polynomial we need it to be weighted
***** How?
We make think of this as the CNOT trick we did in the trace calculation of the submatrix. The CNOT trick caused the unwanted qubit to be orthogonal to all the others, and not to contribute anything. Instead of a CNOT we can perform a controlled rotation, where the orthogonal part will get cancelled, and the part in the same direction will get smaller.
** Main Concepts
:PROPERTIES:
:EXPORT_LaTeX_CLASS: beamer
:EXPORT_LaTeX_CLASS_OPTIONS: [leqno,fleqn]
:EXPORT_BEAMER_THEME: PaloAlto
:EXPORT_OPTIONS: H:2 d:nil
:EXPORT_LaTeX_HEADER: \input{dqc1_headers}
:EXPORT_FILE_NAME: main_concepts
:END:

#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt) 
*** Main Concepts
**** Main Concepts
:PROPERTIES:
:BEAMER_opt: fragile
:END:

***** A simple knot $k$ equivalent to the unknot                :B_block:BMCOL:
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ENV: block
:END:

#+begin_src latex :noweb yes
\begin{diagram}[width=80,height=50]
<<unknot-equivalent>>
\end{diagram}
#+end_src
<<current-stage>>
***** Thanks to everyone else                             :B_block:BMCOL:
:PROPERTIES:
:BEAMER_COL: 0.48
:BEAMER_ACT: <2->
:BEAMER_ENV: block
:END:
for contributing to the discussion

* Notes
1. We need to find out how to translate a knot to a braid.
2.
3.
** 
#+begin_quote
The main technical difficulty is obtaining the Jones polynomial
as a trace over the entire Hilbert space rather than as a summation of some subset of the diagonal matrix
elements. To do this we will not use the path model representation of the braid group, but rather the
Fibonacci representation, as described in the next section.
#+end_quote
We want to compute only the valid inputs that follow the constraing the two * cannot be adjacent.
** 

#+begin_quote
These rules do not allow the rightmost symbol or leftmost
symbol of the string to change.
#+end_quote
As only the middle symbol changes, we are guaranteed that two * will not be formed with the string's neighbours.
** 
Why *formal* linear combinations?
* Screenshots                                                        :ATTACH:
:PROPERTIES:
:Attachments: trefoil%20braid.jpg
:ID:       7003c715-88fc-4b3c-b2ce-4cef1637c279
:END:
* Testing diagrams slide
:PROPERTIES:
:EXPORT_LaTeX_CLASS: beamer
:EXPORT_LaTeX_CLASS_OPTIONS: [leqno,fleqn]
:EXPORT_BEAMER_THEME: PaloAlto
:EXPORT_OPTIONS: H:2 d:nil
:EXPORT_LaTeX_HEADER: \input{dqc1_headers}
:EXPORT_FILE_NAME: test
:END:

#+beamer: \beamerdefaultoverlayspecification{<+->}

#+author:Ohad Barta, Amitai Hoze
** Test
*** Test
:PROPERTIES:
:BEAMER_opt: fragile
:END:
**** COMMENT Test
#+name: example-diagrams
#+header: :var diagram_act="<1->"
#+header: :var diagram_width=300
#+header: :var diagram_height=150
#+header: :var diagram=tl-diagram
#+header: :var diagram-generation="dia = fromTL True False 2 (fromBraid s1)"
#+begin_src latex :noweb yes :exports none
\begin{onlyenv}diagram_act
  \begin{diagram}[width=diagram_width,height=diagram_height]
    diagram
    diagram-generation
  \end{diagram}
\end{onlyenv}
#+end_src
# "<1>",300,150,tl-diagram,"dia = fromTL True False 2 (fromBraid s1)")>>
#+begin_src latex :noweb yes
<<example-diagrams()>>
#+end_src
**** Test
#+name: diagrams-slide
#+header: :var diagram=tl-diagram
#+begin_src latex :noweb yes :exports none
\begin{onlyenv}diagram_act
  \begin{diagram}[width=300,height=150]
    diagram
    dia = fromTL False False 2 (e1)
  \end{diagram}
\end{onlyenv}
#+end_src
#+begin_src latex :noweb yes
<<diagrams-slide()>>
#+end_src

* Settings
** Export Options
#+options: todo:nil tags:nil d:(not "source_table" "comment" "todo")
** Babel Library
#+name: org-table-to-latex-matrix
#+begin_src emacs-lisp :var table='((:head) hline (:body))
(require 'cl)
(flet ((to-tab (tab)
               (orgtbl-to-generic
                (mapcar (lambda (lis)
                          (if (listp lis)
                              (mapcar (lambda (el)
                                        (if (stringp el)
                                            el
                                          (format "%S" el))) lis)
                            lis)) tab)
                (list :lend " \\\\" :sep " & " :hline "\\hline"))))
  (org-fill-template
   "%table"
   (list
    (cons "table"
          ;; only use \midrule if it looks like there are column headers
          (if (equal 'hline (second table))
              (concat (to-tab (list (first table)))
                      "\n\\midrule\n"
                      (to-tab (cddr table)))
            (to-tab table))))))
#+end_src
** In buffer
#+STARTUP: entitiespretty
#+STARTUP: inlineimages
#+STARTUP: hideblocks
** Mobile Org
#+LAST_MOBILE_CHANGE: 2014-11-24 23:09:51
** Emacs
# Local Variables:
# eval: (load "qc.el")
# End:


