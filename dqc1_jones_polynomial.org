* DQC1 complexity class and the trace estimation problem
:PROPERTIES:
:EXPORT_LaTeX_CLASS: beamer
:EXPORT_LaTeX_CLASS_OPTIONS: [leqno,fleqn]
:EXPORT_BEAMER_THEME: PaloAlto
:EXPORT_OPTIONS: H:2
:EXPORT_LaTeX_HEADER: \input{dqc1_headers}
:EXPORT_FILE_NAME: dqc1_trace_estimation_beamer
:END:

#+begin_comment
This was in the original presentation
\frame{\titlepage} 
\begin{frame}[allowframebreaks]
\frametitle{Table of contents}
{\tableofcontents}
\end{frame}
#+end_comment
** The DQC1 complexity class
*** The DQC1 complexity class
DQC1 class is the class of decidable languages with algorithm $A$ such that:

-  $A$ starts with one clean qubit in state $\ket{0}$, and $n$ qubits in
   the maximally mixed state
-  $A$ may perform any unitary operation
-  $A$ can only perform a measurement of the clean qubit at the end of
   the algorithm
-  $A$ has no access to a classical computer, so its not promised that
   $P \subset DQC1$
-  $A$ cannot be invoked many times in parallel
-  $A$ runs in polynomial time
-  $\forall x$, $A$ decides if $x \in L$ correctly with probability of
   at least $\frac{2}{3}$
*** The trace estimation problem is in DQC1
**** Trace estimation problem
Given a quantom circuit, what is the trace of its unitary operation?
**** Completeness
A language L is said to be "complete" in the class DQC1, if:
- $L \in DQC1$
- $\forall L_{0} \in DQC1$ there is a reduction from $L_{0}$ to $L$, such that the reduction algorithm is in DQC1
*** The Hadamard test
:source_table:
#+name: hadamard-test
| \lstick{\ket{0}} | \gate {H} | \ctrl{1}  | \gate {H} | \meter | \qw |
| \lstick{\psi}   | {/} \qw    | \gate {U} | {/} \qw    | \qw    | \qw |
:end:
#+begin_src latex :noweb yes
\inlineQcircuit{
  <<org-table-to-latex-matrix(hadamard-test)>>
}
#+end_src
*** The Hadamard test
We will show that this circuit indeed calculates the trace of U
**** After the first hadamard gate
\begin{align*}
   \Ket{+}\psi = \frac{1}{\sqrt{2}}\Ket{0}\Ket{\psi} + \frac{1}{\sqrt{2}}\Ket{1}\Ket{\psi}
\end{align*}
**** After the C-U operation
\begin{align*}
   \frac{1}{\sqrt{2}}\Ket{0}\Ket{\psi} + \frac{1}{\sqrt{2}}\Ket{1}U\Ket{\psi}
\end{align*}
**** After the final hadamard operation
#+begin_src latex
\begin{align*}
   \frac{1}{2}\Ket{0}\Ket{\psi} + \frac{1}{2}\Ket{1}\Ket{\psi}\ +\frac{1}{2}\Ket{0}U\Ket{\psi}\ -  \frac{1}{2}\Ket{1}U\Ket{\psi} = \\
   \frac{\Ket{\psi} + U\Ket{\psi}}{2}\Ket{0} + \frac{\Ket{\psi} - U\Ket{\psi}}{2}\Ket{1}
\end{align*}
#+end_src
*** The Hadamard test
Therefore, the propability to measure 0 at the end is:

\begin{align*}
\rho_{0} &= (\frac{\bra{\psi} + \bra{\psi}U^\dagger}{2})(\frac{\ket{\psi} + U\ket{\psi}}{2}) = \\
    &= \frac{1}{4}(\bra{\psi}\ket{\psi} + \bra{\psi}U^\dagger\ket{\psi} + \bra{\psi}U\ket{\psi} + \bra{\psi}U^\dagger U\ket{\psi}) = \\
    &= \frac{1}{2} + \frac{1}{4}(\bra{\psi}U^\dagger\ket{\psi} + \bra{\psi}U\ket{\psi}) = \\
    &=  \frac{1}{2} + \frac{1}{2}Re(\bra{\psi}U\ket{\psi})
\end{align*}
*** The Hadamard test
As $\psi$ is the completely mixed state, the probability is: \\
\begin{align*}
  \frac{1}{2^{n}}\sum_{x \in \{0,1\}^n}{\frac{1+Re(\bra{x}U\ket{x})}{2}} = \frac{1}{2} + \frac{Re(TrU)}{2^{n+1}}
\end{align*}
Therefore, the problem of trace estimation can be solved with one clean qubit.
** Completeness of trace estimation in DQC1
*** Trace estimation is in DQC1
The start state of any DQC1 problem is one clean qubit (state \(\ket{0}\)), and $n$-qubits in the maximally mixed state. That is, the start state is $\rho = \ket{0}\bra{0} \otimes \frac{I}{2^n}$. We can use the Hadamard test in order to estimate a trace of a unitary operation $U$.
*** Trace estimation is in DQC1
# Next, we will want to show that trace estimation is hard in DQC1 \cite{SJ2008}.
**** Proof
Suppose we have some language $L \in DQC1$, and some $x$, and we want to decide if $x \in L$. We apply a unitary matrix $U$ on the DQC1 start state $\rho=\ket{0}\bra{0}\frac{I}{2^n}$ and get the state $\rho_{final} = U \rho U^\dagger = U\ket{0}\bra{0}\frac{I}{2^n}U^\dagger$.
The probability to measure 0 equals to the trace of the final matrix, when we enforce the first bit to be zero, or:
\begin{align*}
 p_{0} &= Tr[(\ket{0}\bra{0}\otimes I)\rho_{final}] \\
     &= 2^{-n}Tr[(\ket{0}\bra{0} \otimes I)U(\ket{0} \bra{0} \otimes I)U^\dagger]
\end{align*}
Unfortunately - this matrix isn't unitary!!
*** Trace estimation is in DQC1
To resolve this issue, we examine the following quantom circuit C:
:source_table:
#+name: trace-estimation
|   | \qw    | \multigate{1}{U^\dag} | \ctrl{2} | \multigate{1}{U} | \ctrl{3} | \qw    |
|   | {/} \qw | \ghost{U^\dag}       | \qw      | \ghost{U}        | \qw      | {/} \qw |
|   | \qw    | \qw               | \targ    | \qw              | \qw      | \qw    |
|   | \qw    | \qw               | \qw      | \qw              | \targ    | \qw    |
:end:
#+begin_src latex :noweb yes
\inlineQcircuit{
  <<org-table-to-latex-matrix(trace-estimation)>>
}
#+end_src
**** Proposition 1
 $\frac{1}{4}Tr[C]=Tr[(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I)U^\dagger]$
*** Trace estimation is in DQC1
**** 
$Tr[C] = \sum_{x \in \{0,1\}^n} \bra{x}C\ket{x}$, and in a similar way,
\begin{align*}
&Tr[(\ket{0}\bra{0} \otimes I)U(\ket{0}\bra{0} \otimes I)U^\dagger] = \\
&= \sum_{x \in \{0,1\}^n} \bra{x}(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I{U^\dagger})\ket{x}
\end{align*}
**** 
Suppose that after applying $U$ on some state $\psi$, we got a non-zero component in the first qubit.
**** 
After the CNOT gate, this component will flip one of the last qubits, creating a new state that is orthogonal to $\psi$.
**** 
By the equation above, we see that in this case, this component would contribute nothing to the trace of C.
*** Trace estimation is in DQC1
**** 
On the other hand, the zero-component we get after applying $U$ on $\psi$, doesn't change the last qubit, so the contribution to the trace of C will be $\bra{\psi}(\bra{0}\ket{0} \otimes U)\ket{\psi}$
**** 
After considering the two CNOT gates, the contribution of $\psi$ to the trace of C will be $\bra{\psi}(\ket{0}\bra{0}\otimes I)U(\ket{0}\bra{0}\otimes I{U^\dagger})\ket{\psi}$
**** 
Therefore, the two circuit traces has the exact same components and are equal, up to factor of 4, which comes from the "free choice" in the values of the two last qubits in C.
*** Trace estimation is DQC1 complete
-  We didn't compute the trace accurately, rather got an approximation via the expectation of the algorithm.
-  We measure a polynomial number of points on the trace, so the variance of our estimation is $O(\frac{1}{poly(n)})$, and with high probability we get a  $O(\frac{1}{poly(n)})$ estimation.
*** Trace estimation is DQC1 complete
-  On the other hand, an approximation of $\frac{1}{poly(n)}$ to the
   expression $\frac{Tr(U)}{2^{n+1}}$ is enough to decide every problem
   in DQC1 using the analysis above
-  Therefore, we showed that getting a $\frac{2^{n}}{poly(n)}$ additive-
   approximation to the trace is a DQC1-complete problem
** Adding few more clean bits doesn't give extra power
*** Adding few more clean bits doesn't give extra power
*** Adding few more clean bits doesn't give extra power
*** Adding few more clean bits doesn't give extra power
** References
* Settings
** Export Options
#+options: todo:nil tags:nil d:(not "source_table" "comment" "todo")
** Babel Library
#+name: org-table-to-latex-matrix
#+begin_src emacs-lisp :var table='((:head) hline (:body))
(require 'cl)
(flet ((to-tab (tab)
               (orgtbl-to-generic
                (mapcar (lambda (lis)
                          (if (listp lis)
                              (mapcar (lambda (el)
                                        (if (stringp el)
                                            el
                                          (format "%S" el))) lis)
                            lis)) tab)
                (list :lend " \\\\" :sep " & " :hline "\\hline"))))
  (org-fill-template
   "%table"
   (list
    (cons "table"
          ;; only use \midrule if it looks like there are column headers
          (if (equal 'hline (second table))
              (concat (to-tab (list (first table)))
                      "\n\\midrule\n"
                      (to-tab (cddr table)))
            (to-tab table))))))
#+end_src
** In buffer
#+STARTUP: entitiespretty
#+STARTUP: inlineimages
#+STARTUP: hideblocks
** Mobile Org
#+LAST_MOBILE_CHANGE: 2014-11-24 23:09:51
** Emacs
# Local Variables:
# eval: (load "qc.el")
# End:
